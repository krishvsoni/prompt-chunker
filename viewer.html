<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pipeline Results Viewer</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 18px; color:#111 }
    h1,h2,h3 { margin: 6px 0 }
    .grid { display:flex; gap:12px; flex-wrap:wrap }
    .card { border:1px solid #ddd; padding:12px; border-radius:6px; background:#fff; min-width:260px }
    pre { white-space:pre-wrap; max-height:240px; overflow:auto; background:#f7f7f7; padding:10px }
    table { border-collapse:collapse; width:100% }
    th,td{border:1px solid #eee;padding:6px;text-align:left}
    .small { font-size:0.9em; color:#666 }
    .chunk { margin-bottom:8px; border-bottom:1px dashed #eee; padding-bottom:6px }
    button { padding:6px 8px; margin:4px 0 }
    .meta { font-size:0.85em; color:#333 }
  </style>
</head>
<body>
  <h1>Pipeline Results Viewer</h1>
  <p class="small">This page displays aggregated summary, per-document comparisons, recommendations and chunk previews.</p>

  <h2>Aggregate Summary</h2>
  <div id="aggregate"></div>

  <h2>Per-Document Results</h2>
  <div id="documents"></div>

  <h2>Raw JSON</h2>
  <details><summary>Show raw JSON</summary><pre id="raw"></pre></details>

  <script>
    async function loadAndRender(){
      let data;
      try{
        const resp = await fetch('output/summary.json');
        if(!resp.ok) throw new Error('Failed to fetch output/summary.json: '+resp.status+' '+resp.statusText);
        data = await resp.json();
      }catch(e){
        document.body.innerHTML = '<h2>Error loading output.json</h2><pre>'+String(e)+'</pre>';
        return;
      }

      function mkTable(obj){
        const tbl = document.createElement('table');
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        trh.innerHTML = '<th>Metric</th><th>PyPDF</th><th>Sherpa</th><th>Prompt</th>';
        thead.appendChild(trh);
        tbl.appendChild(thead);
        const tbody = document.createElement('tbody');
        
        function getValue(data, key) {
          if (!data) return 'N/A';
          const val = data[key];
          if (val === undefined || val === null) return 'N/A';
          if (typeof val === 'object' && val !== null) {
            // Handle nested objects with 'value' property
            if ('value' in val) {
              const v = val.value;
              const unit = val.unit || val.scale || '';
              const k = val.k ? ` (K=${val.k})` : '';
              if (typeof v === 'number') {
                return v.toFixed(2) + (unit ? ` ${unit}` : '') + k;
              }
              return v + (unit ? ` ${unit}` : '') + k;
            }
            return JSON.stringify(val);
          }
          if (typeof val === 'number') return val.toFixed(2);
          return val;
        }
        
        // Updated metrics mapping: new key -> display label
        const metrics = [
          { key: 'total_chunks', label: 'Total chunks' },
          { key: 'avg_chunk_length', label: 'Avg chunk length' },
          { key: 'avg_quality', label: 'Avg quality (0-1)' },
          { key: 'relevance_pct', label: 'Relevance %' },
          { key: 'semantic_accept_pct', label: 'Semantic Accept %' },
          { key: 'topk_sufficiency_pct', label: 'Top-K Sufficiency %' },
          { key: 'boundary_confidence_pct', label: 'Boundary Confidence %' },
          { key: 'total_time_seconds', label: 'Total time (s)' }
        ];
        
        for(const m of metrics){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${m.label}</td>` +
            `<td>${getValue(obj.pypdf, m.key)}</td>`+
            `<td>${getValue(obj.sherpa, m.key)}</td>`+
            `<td>${getValue(obj.prompt, m.key)}</td>`;
          tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
        return tbl;
      }

      // Aggregate
      const aggDiv = document.getElementById('aggregate');
      aggDiv.appendChild(mkTable(data.summary));
      
      // Add stage breakdown table
      if (data.summary.pypdf?.stage_breakdown || data.summary.sherpa?.stage_breakdown || data.summary.prompt?.stage_breakdown) {
        const stageDiv = document.createElement('div');
        stageDiv.innerHTML = '<h3>Stage Timing Breakdown (seconds)</h3>';
        const stageTbl = document.createElement('table');
        const stageHead = document.createElement('thead');
        stageHead.innerHTML = '<tr><th>Stage</th><th>PyPDF</th><th>Sherpa</th><th>Prompt</th></tr>';
        stageTbl.appendChild(stageHead);
        const stageBody = document.createElement('tbody');
        
        const stages = ['parse', 'boundary_detection', 'structure_analysis', 'chunk_assembly', 'validation_refinement', 'embedding', 'indexing'];
        const stageLabels = {
          parse: 'Parse/Extract',
          boundary_detection: 'Boundary Detection',
          structure_analysis: 'Structure Analysis',
          chunk_assembly: 'Chunk Assembly',
          validation_refinement: 'Validation/Refinement',
          embedding: 'Embedding',
          indexing: 'Indexing'
        };
        
        for (const stage of stages) {
          const tr = document.createElement('tr');
          const pypdfVal = data.summary.pypdf?.stage_breakdown?.[stage] ?? 0;
          const sherpaVal = data.summary.sherpa?.stage_breakdown?.[stage] ?? 0;
          const promptVal = data.summary.prompt?.stage_breakdown?.[stage] ?? 0;
          tr.innerHTML = `<td>${stageLabels[stage] || stage}</td><td>${pypdfVal.toFixed(2)}</td><td>${sherpaVal.toFixed(2)}</td><td>${promptVal.toFixed(2)}</td>`;
          stageBody.appendChild(tr);
        }
        stageTbl.appendChild(stageBody);
        stageDiv.appendChild(stageTbl);
        aggDiv.appendChild(stageDiv);
      }

      // Add metric explanation
      if (data.analysis?.metric_explanation) {
        const expDiv = document.createElement('div');
        expDiv.style.background = '#e7f3ff';
        expDiv.style.border = '1px solid #0d6efd';
        expDiv.style.borderRadius = '6px';
        expDiv.style.padding = '12px';
        expDiv.style.marginTop = '12px';
        expDiv.innerHTML = `<strong> Metric Note:</strong> ${data.analysis.metric_explanation}`;
        aggDiv.appendChild(expDiv);
      }
      
      // Add K values info
      if (data.k_values) {
        const kDiv = document.createElement('p');
        kDiv.className = 'small';
        kDiv.innerHTML = `<strong>K Values:</strong> Relevance K=${data.k_values.relevance_k}, Sufficiency K=${data.k_values.sufficiency_k}`;
        aggDiv.appendChild(kDiv);
      }

    //   // Method Analysis: Flaws & Advantages
    //   if(data.analysis){
    //     const analysisDiv = document.createElement('div');
    //     analysisDiv.innerHTML = '<h2>Method Flaws & Advantages</h2>';
    //     const analysisGrid = document.createElement('div'); analysisGrid.className='grid';

    //     const mkListCard = (title, items, style='flaw')=>{
    //       const card = document.createElement('div'); card.className='card';
    //       card.innerHTML = `<h4>${title}</h4>`;
    //       const ul = document.createElement('div'); ul.className='meta';
    //       if(!items||!items.length){ ul.innerHTML='<em>No data</em>'; }
    //       else { ul.innerHTML = items.slice(0,8).map(i=>`<div style="margin:3px 0;color:${style==='adv'?'#080':'#800'}">${style==='adv'?'✅':'❌'} ${i}</div>`).join(''); }
    //       card.appendChild(ul);
    //       return card;
    //     };

    //     const flaws = data.analysis.flaws || {};
    //     analysisGrid.appendChild(mkListCard('PyPDF Flaws', flaws.pypdf_flaws, 'flaw'));
    //     analysisGrid.appendChild(mkListCard('Sherpa Flaws', flaws.sherpa_flaws, 'flaw'));
    //     analysisGrid.appendChild(mkListCard('Prompt Advantages', flaws.prompt_solutions, 'adv'));
    //     if(data.analysis.prompt_disadvantages){
    //       analysisGrid.appendChild(mkListCard('Prompt Disadvantages', data.analysis.prompt_disadvantages, 'flaw'));
    //     }
    //     analysisDiv.appendChild(analysisGrid);

    //     // Metric explanation
    //     if(data.analysis.metric_explanation){
    //       const exp = document.createElement('p');
    //       exp.className='small';
    //       exp.style.marginTop='12px';
    //       exp.innerHTML = '<strong>Metric Change:</strong> '+data.analysis.metric_explanation;
    //       analysisDiv.appendChild(exp);
    //     }

    //     // Comparison report (collapsible)
    //     if(data.analysis.comparison_report){
    //       const det = document.createElement('details');
    //       det.innerHTML = '<summary>Full Comparison Report</summary>';
    //       const pre = document.createElement('pre'); pre.textContent = data.analysis.comparison_report;
    //       det.appendChild(pre);
    //       analysisDiv.appendChild(det);
    //     }

    //     aggDiv.parentNode.insertBefore(analysisDiv, aggDiv.nextSibling);
    //   }

      // Documents
      const docsDiv = document.getElementById('documents');
      data.results.forEach((doc, idx)=>{
        const card = document.createElement('div'); card.className='card';
        const title = document.createElement('h3'); title.textContent = `Document ${idx+1}`;
        card.appendChild(title);

        // Recommendation
        const comp = doc.comparison || {};
        if(comp.recommendation){
          const rec = document.createElement('p'); rec.innerHTML = '<strong>Recommendation:</strong> '+comp.recommendation;
          card.appendChild(rec);
        }

        // Metrics per method
        const flex = document.createElement('div'); flex.className='grid';
        ['pypdf','sherpa','prompt'].forEach(m=>{
          const mcard = document.createElement('div'); mcard.className='card';
          const mh = document.createElement('h4'); mh.textContent = m.toUpperCase(); mcard.appendChild(mh);
          const metrics = (doc[m] && doc[m].metrics) || {};
          const ul = document.createElement('div'); ul.className='meta';
          ul.innerHTML = `Chunks: ${metrics.chunk_count|| ((doc[m]&&doc[m].chunks)?doc[m].chunks.length:0)}<br/>Time: ${metrics.processing_time||metrics.total_processing_time||0}s`;
          mcard.appendChild(ul);

          // chunk list preview
          const chunks = (doc[m] && doc[m].chunks) || [];
          const list = document.createElement('div');
          list.style.maxHeight='220px'; list.style.overflow='auto';
          chunks.slice(0,10).forEach(c=>{
            const div = document.createElement('div'); div.className='chunk';
            const h = document.createElement('div'); h.innerHTML = `<strong>${c.chunk_id}</strong> <span class="small">(${c.source})</span>`;
            div.appendChild(h);
            const p = document.createElement('div'); p.innerHTML = `<em>${(c.metadata && c.metadata.summary) ? c.metadata.summary : (c.text||'').slice(0,200)+'...'}</em>`;
            div.appendChild(p);
            const btn = document.createElement('button'); btn.textContent='Show full';
            const pre = document.createElement('pre'); pre.style.display='none'; pre.textContent = c.text||'';
            btn.onclick = ()=>{ pre.style.display = pre.style.display==='none' ? 'block' : 'none'; btn.textContent = pre.style.display==='none' ? 'Show full' : 'Hide'; };
            div.appendChild(btn); div.appendChild(pre);
            list.appendChild(div);
          });
          if(chunks.length>10){ const more = document.createElement('div'); more.className='small'; more.textContent = `Showing 10 of ${chunks.length} chunks`; list.appendChild(more); }
          mcard.appendChild(list);
          flex.appendChild(mcard);
        });

        card.appendChild(flex);
        docsDiv.appendChild(card);
      });

      document.getElementById('raw').textContent = JSON.stringify(data, null, 2);
    }
    loadAndRender();
  </script>
</body>
</html>